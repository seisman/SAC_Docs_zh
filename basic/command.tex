\section{SAC命令初探}
\subsection{SAC命令长什么样？}
一个完整的SAC命令一般由``命令+选项+参数''构成，其中命令必须有，选项和参数可以成对
出现，也可以只出现其中一个。命令、选项以及参数之间用空格分开。如果要将多个命令写在
一行，要用分号隔开每个命令。例如：
\begin{SACCode}
SAC> funcgen random delta 0.1 npts 1000
SAC> rmean; rtrend; taper                 // 一行内多个命令用分号隔开
SAC> write rand.SAC
\end{SACCode}
其中，\verb+funcgen+、\verb+write+、\verb+rmean+、\verb+rtrend+
和~\verb+taper+是命令；\verb+random+是选项；
\verb+0.1+是选项~\verb+delta+的参数、\verb+1000+是选项
~\verb+npts+的参数；而~\verb+rand.SAC+则是一个无选项的参数\footnote{其实
可以有很多选项，这里都省略了。}。

\begin{Tips}
官方文档的原文是``command''、``keyword''和``option''，
本文档v2.0中译为``命令''，``关键字''和``参数''。
个人感觉，无论是官方的用词还是v2.0版的译词都很容易让使用C语言和Linux的人困惑，
因而v3.0中一律将其改为命令(command)、选项(option)和参数(argument)。

这里解释一下选项(option)和参数(argument)的区别。一个命令有哪些选项是由命令规定的，
其控制了命令的一些特性，因而选项的作用是告诉命令``我\textbf{要}改某个特性''。
但是具体\textbf{怎么}改呢？
这个就交给参数来控制了。命令或选项只规定了参数的类型(整型、浮点型、字符串、枚举型或者逻辑型)，
用户需要根据自己的需求给定参数值。
\end{Tips}

\subsection{大小写}
SAC的命令和选项都是不区分大小写的，这意味着你可以根据自己的喜好使用~\verb+funcgen+
或者~\verb+FUNCGEN+，SAC在解释命令前都会将其转换为大写字母。

需要注意的是，由于Linux本身是区分大小写的，所以对于出现在参数中的文件名、目录名
或者由引号包围的字符串来说，大小写是完全不同的。比如~\verb+rand.SAC+和
\verb+RAND.SAC+是两个完全不同的参数。

\subsection{命令简写}
SAC的大多数命令以及选项都有简写形式。比如上面的命令简写形式如下：
\begin{SACCode}
SAC> fg r d 0.1 n 1000
SAC> rmean; rtr; taper
SAC> w rand.SAC
\end{SACCode}

命令和选项究竟可以简写成怎样的形式，是由SAC自身规定的。简写的好处在于，在不产生歧义
的前提下尽量减少用户的击键数；坏处在于，若对命令不是足够熟悉，简写后的命令变得很
难读和难理解。比如你一看就知道~\verb+delta+代表的是采样周期
\footnote{也称为采样时间，即两次数据采样的时间间隔，本文档将统一使用``采样周期''。}，
而~\verb+d+却不那么直观，可能是~\verb+delta+，也可能是~\verb+demon+。
所以，在终端调用SAC时，可以多用简写以减少击键数，但在脚本中调用SAC时应仅使用那些
常用命令的简写，不要滥用，否则一段时间后你会看不懂自己写的脚本的。

\subsection{查看命令语法}
SAC自带了英文的帮助文档，详细解释了每个命令的语法，可以通过~\nameref{cmd:help}~命令
查看相应文档:
\begin{SACCode}
SAC> help funcgen write   // 命令的简写是h fg w
\end{SACCode}
也可以直接查看~\verb+$SACHOME/aux/help+下的文档，或者查看本文档的命令部分。

\subsection{参数默认值}
为了让SAC易学易用，几乎所有命令参数都有一个``系统默认参数值''，这些``系统默认参数值''
都是经过精心挑选的，
同时用户又可以随时修改参数值。这样的设计使得SAC易用同时又不失灵活性。

下面以C语言为例做一些说明\footnote{有些地方不是很准确。}，希望能够帮助理解SAC参数
的一些特点。

在C语言中，函数有主函数和子函数之分，变量又有全局变量和局部变量之分。所有的变量
都可以被初始化为适当的值。

任意一个子函数，都可以使用全局变量的值，即函数的执行可以被全局变量所控制，
同时也可以修改全局变量的值。这使得代码的管理和调试变得困难。实际写程序时
一般会定义专门的子函数来修改全局变量。

任意一个子函数，又都有自己的局部变量。这些局部变量在每次子函数被调用时都会被定义、初始化、
使用和赋值，一旦子函数调用结束，变量即被撤销。如果给这些变量加上~\verb+static+~
修饰符，则这些局部变量变身为静态局部变量。

静态局部变量，会在程序刚开始的时候就完成初始化，也是唯一的一次初始化。静态局部变量
仅在定义它的子函数里可见，子函数可以任意修改静态局部变量的值，
但是每次子函数调用结束时变量不会被撤销，因此再次调用一个子函数时，静态局部变量的值
可能已经被上一次的子函数调用所修改。

SAC中有与之相对应的一些概念。sac就是一个主函数，每一个命令都是一个子函数。所以SAC
命令可以分为2类：
\begin{description}
\item[操作执行类] 对数据进行某些操作(受全局变量控制，同时又有自己的静态局部变量)；
\item[参数设定类] 改变SAC的全局参数值(即C语言中专门用于修改全局变量的子函数)；
\end{description}

在启动SAC（主函数）的时候，所有的选项(C语言中的全局变量和静态局部变量)都会被初始化为
指定的``系统默认参数值''(全局变量和静态局部变量的唯一一次初始化)。

使用参数设定类命令的时候，其修改了SAC的全局参数，会影响接下来与之相关的所有其它
命令的执行效果。使用操作执行类命令的时候，在命令中设定参数，相当于修改静态局部变量的值，不仅会
影响当前命令的执行，也会影响之后所有同名命令的执行。

当你在某个命令中为某个选项指定了一个参数值的时候，该参数值会
成为该命令的该选项的``参数当前值''，该``参数当前值''即成为接下来所有
该命令的该选项的``当前默认值''。

鉴于SAC的这样一个特性，在一次会话中，多次执行同一个命令时，一定需要注意选项的当前值
是多少，因为这可能会影响到后面的一系列结果，这个必须理解和牢记！

\begin{Tips}
当你在一次会话中执行了很多个命令的时候，SAC参数可能已经被弄得一片混乱，
你可以使用~\nameref{cmd:inicm}~命令在不退出SAC的情况下重新初始化。
\end{Tips}

下面用例子解释一下：
\begin{SACCode}
SAC> funcgen
SAC> plot
SAC> funcgen step delta 0.1 npts 1000
SAC> plot
SAC> funcgen boxcar
SAC> plot
\end{SACCode}

\begin{enumerate}
\item \verb+funcgen+的默认值为~\verb+funcgen impulse npts 100 delta 1.0 begin 0.+。
\item 第一个~\verb+funcgen+命令没有使用任何选项和参数，其直接使用系统默认值，
    生成一个脉冲数据，并保存到内存中。该数据的起始时间为~\verb+0+，采样周期为~\verb+1.0+，
    数据点数为~\verb+100+。
\item \verb+plot+命令会打开一个绘图窗口，并将内存中的数据绘制在窗口中；
\item 第二个~\verb+funcgen+命令生成了一个step函数
    \footnote{注意：内存中的脉冲函数已经没了。}，
    并设置其采样周期为~\verb+0.1+，数据点数为~\verb+1000+。
\item \verb+0.1+和~\verb+1000+分别成为~\verb+delta+和~\verb+npts+的``参数当前值''。
\item 第三个~\verb+funcgen+命令生成了boxcar函数，从绘图结果可以看出~\verb+delta+的值为
    \verb+0.1+，\verb+npts+的值为~\verb+1000+。即继承了上一次命令的参数值。
\end{enumerate}
