事件信息
========

**相关头段**\ ：\ ``evla``\ 、\ ``evlo``\ 、\ ``evdp``\ 、\ ``mag``\ 、
``o``\ 、\ ``nzyear``\ 、\ ``nzjday``\ 、\ ``nzhour``\ 、
``nzmin``\ 、\ ``nzsec``\ 、\ ``nzmsec``

**相关脚本**\ ：\ :ref:`Perl 脚本 <subsec:eventinfo.pl>`\ 、\ :ref:`Python 脚本 <subsec:eventinfo.py>`

若 SAC 文件中没有事件信息或者事件信息不准确，则需要用户从地震目录中
获取事件的发震时刻、经度、纬度、深度和震级信息，并将这些
信息写入到SAC文件的头段中。SAC提供了用于可以修改头段变量的命令
:doc:`/commands/chnhdr`\ ，以及将修改后的头段变量写到磁盘文件的命令
:doc:`/commands/writehdr`\ [1]_。

经纬度、深度与震级
------------------

想要修改事件的经纬度、深度和震级，操作如下：

.. code-block:: bash

    SAC> r cdv.?
    SAC> ch evla 37.52 evlo -121.68 evdp 5.95   # 修改三个头段变量
    SAC> ch mag 5.0                             # 修改一个头段变量
    SAC> wh                                     # 将修改后的头段写入文件

.. _subsec:origin-time:

发震时刻
--------

通常，需要将发震时刻信息写入 SAC 头段，并设置 SAC 文件的参考时刻为发震时刻。
这样设置的好处在于，可以直观地从 X 轴坐标上读取震相走时。要实现这一操作，
需要用到 :doc:`/commands/chnhdr` 的两个特殊用法。

先看看如何修改\ **一个** SAC 文件的发震时刻，假设发震时刻为1987年06月22日
11时10分10.363秒：

.. code-block:: bash

    SAC> r ./cdv.z
    SAC> ch o gmt 1987 173 11 10 10 363   # 06月22日是第173天
    SAC> lh kzdate kztime o

         kzdate = JUN 22 (173), 1987
         kztime = 11:09:56.363
              o = 1.400000e+01       # 发震时刻相对于参考时刻的时间为14秒
    SAC> ch allt -14 iztype IO       # 参考时间加14秒，其他时间减14秒
    SAC> lh kzdate kztime o

         kzdate = JUN 22 (173), 1987
         kztime = 11:10:10.363
              o = 0.000000e+00
    SAC> wh                          # 写回磁盘

上面的例子中，首先从地震目录中获取了地震的发震时刻，然后计算发震日期
是一年中的第几天，本例中为第173天，再利用“``ch o gmt yyyy ddd hh mm sss xxx``”
语法将发震时刻赋值给头段变量 ``o``\ ，SAC会自动将发震时刻转换为
相对于参考时刻的相对时间。此时 SAC 文件的参考时刻为“``1987-06-22T11:09:56.363``”，
而 ``o`` 值对应的时刻为发震时刻“``1987-06-22T11:10:10.363``”，所以
头段变量 ``o`` 的值为发震时刻相对于参考时刻的时间差，即 14 秒。

将发震时刻写入头段之后，还需要将参考时刻修改为发震时刻，与此同时还要
修改所有的相对时间。\ ``ch allt xx.xx`` 的功能是将所有已定义的
相对时间加上 ``xx.xx`` 秒，同时从参考时刻中减去 ``xx.xx`` 秒，
此时参考时刻即为发震时刻，而 ``o`` 值为0。

上面的做法需要执行5个命令才能实现，而且需要人工查看 ``o`` 的值，
因而无法用于处理大量数据。下面就对这一例子做进一步简化，这其中需要使用
SAC 提供的“在命令中引用头段变量的值”的功能。具体的语法以及用法在
:doc:`/macros/index` 一章中会介绍。

.. code-block:: bash

    SAC> r cdv.z
    SAC> ch o gmt 1987 173 11 10 10 363
    SAC> ch allt (0 - &1,o&) iztype IO
    SAC> wh

在这个例子中，\ ``(0 - &1,o&)`` 代替了上个例子中的 ``-14``\ 。
简单介绍一下 ``(0 - &1,o&)``\ 的含义，\ ``&1,o&`` 表示引用内存中
第一个 SAC 文件的头段变量 ``o`` 的值（即14），然后 ``(0 - 14)``
得到的结果即为 ``-14``\ 。此处简化的优点在于，不需要使用 ``lh o``
查看头段变量的值，完全可以实现自动化。

在 SAC v101.6 及之后的版本中，上例中的 ``(0 - &1,o&)`` 还可以写成
``(0-&1,o&)``\ 、\ ``(-&1,o&)`` 或 ``(-&1,o)``\ 。 而在 SAC
v101.5c 及之前的版本中，只能使用 ``(0 - &1,o&)``\ ，注意减号
两边的空格。考虑到命令的通用性，建议使用上面示例中的写法。

上面的示例只适用于为一个 SAC 数据添加发震时刻的情况。如果要一次性为多个
SAC 数据添加同样的发震时刻，最直观的想法是：

.. code-block:: bash

    SAC> r *.SAC
    SAC> ch o gmt 1987 173 11 10 10 363
    SAC> ch allt (0 - &1,o&) iztype IO
    SAC> wh

这样的做法是有很大风险的。因为内存中一次性读入了很多 SAC 数据，而在使用
``ch allt`` 命令时，\ ``&1,o&`` 引用的是第一个SAC数据的 ``o``
头段。第二个命令已经保证了内存中所有的数据的 ``o`` 都有相同的绝对
时刻（即发震时刻），只要所有数据的参考时刻是一致的，那么所有数据的头段
变量 ``o`` 的值也必然是一样的。所以当且仅当内存中的所有数据的参考
时刻完全一致时，上面的例子才是安全的。实际处理数据时会遇到很复杂的情况，
“所有数据的参考时刻完全一致”这一假设不一定成立。

在上面的例子的基础上再加一个命令：

.. code-block:: bash

    SAC> r *.SAC
    SAC> synchronize            # 同步所有数据的参考时间
    SAC> ch o gmt 1987 173 11 10 10 363
    SAC> ch allt (0 - &1,o&) iztype IO
    SAC> wh

:doc:`/commands/synchronize` 的作用是使内存中所有的数据拥有相同的参考时刻，
在此命令的基础上，所有数据的头段变量 ``o`` 将拥有相同的值，所以
直接引用第一个头段变量的 ``o`` 值就不再是一件危险的事情了。

.. [1] 也可以使用 ``w over`` 将修改写回磁盘文件。关于 ``wh`` 和 ``w over``
   的区别，参考 :doc:`/tricks-and-traps/wh-wover` 一节。
