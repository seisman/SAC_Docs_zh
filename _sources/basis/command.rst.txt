命令初探
========

SAC 命令长什么样？
------------------

一个完整的 SAC 命令一般由“命令+选项+参数”构成，其中命令必须有，选项和
参数可以成对出现，也可以只出现其中一个。命令、选项以及参数之间用空格
分开。如果要将多个命令写在一行，要用\ **分号**\ 隔开每个命令。例如：

.. code-block:: console

    SAC> funcgen random delta 0.1 npts 1000
    SAC> rmean; rtrend; taper                 # 一行内多个命令用分号隔开
    SAC> write rand.SAC

这几行命令，首先在内存中生成了一个采样间隔为0.1秒，数据长度为1000个点的随机
序列，然后对这一时间序列去均值、去线性趋势和两端尖灭操作，然后将处理后的序列
写入到磁盘文件中。其中：

- ``funcgen``\ 、\ ``write``\ 、\ ``rmean``\ 、\ ``rtrend`` 和 ``taper`` 是命令；
- ``random``\ 、\ ``delta``\ 和 ``npts`` 是选项；
- ``0.1`` 是选项 ``delta`` 的参数，\ ``1000`` 是选项 ``npts`` 的参数；
- ``rand.SAC`` 则是一个无选项的参数\ [1]_。

.. note::

   官方文档的原文是“command”、“keyword”和“option”，本文档 v2.0 中译为“命令”、
   “关键字”和“参数”。个人感觉，无论是官方的用词还是 v2.0 版的译词都很容易让
   使用 C 语言和 Linux 的人困惑，因而 v3.0 中一律将其改为命令（command）、
   选项（option）和参数（argument）。

   这里解释一下选项（option）和参数（argument）的区别。一个命令有哪些
   选项是由命令规定的，其控制了命令的一些特性，因而选项的作用是告诉命令
   “**要**\ 改某个特性”。但是具体\ **怎么**\ 改呢？这个就交给参数
   来控制了。命令或选项只规定了参数的类型（整型、浮点型、字符串、枚举型
   或者逻辑型），用户需要根据自己的需求给定参数值。

大小写
------

SAC 的命令和选项都是不区分大小写的，这意味着你可以根据自己的喜好使用
``funcgen`` 或者 ``FUNCGEN``\ ，SAC 在解释命令前都会将其转换为大写字母。

需要注意的是，由于 Linux 本身是区分大小写的，所以对于出现在参数中的文件名、
目录名或者由引号包围的字符串来说，大小写是完全不同的。比如 ``rand.SAC``
和 ``RAND.SAC`` 是两个完全不同的参数。

命令简写
--------

SAC 的大多数命令及选项都有简写形式。比如上面的命令简写形式如下：

.. code-block:: console

    SAC> fg r d 0.1 n 1000
    SAC> rmean; rtr; taper
    SAC> w rand.SAC

命令和选项究竟可以简写成怎样的形式，是由 SAC 自身规定的。简写的好处在于，
在不产生歧义的前提下尽量减少用户的击键数；坏处在于，若对命令不够熟悉，
简写后的命令变得很难读和难理解。比如你一看就知道 ``delta`` 代表的
是采样周期\ [2]_，而 ``d`` 却不那么直观，可能是 ``delta``\ ， 也可能是
``demon``\ 。所以，在终端调用 SAC 时，可以多用简写以减少击键数，
但在脚本中调用 SAC 时应仅使用那些常用命令的简写，不要滥用，否则一段时间后
你会看不懂自己写的脚本的。

查看命令语法
------------

SAC 自带了英文的帮助文档，详细解释了每个命令的语法，可以通过 :doc:`/commands/help`
命令查看相应文档：

.. code-block:: console

    SAC> help funcgen write   # 命令的简写是h fg w

也可以直接查看 ``$SACHOME/aux/help`` 下的文档，或者查看本文档的
命令部分。

参数默认值
----------

为了让 SAC 易学易用，几乎所有命令参数都有一个“系统默认参数值”，这些
“系统默认参数值”都是经过精心挑选的，同时用户又可以随时修改参数值。
这样的设计使得 SAC 易用同时又不失灵活性。

SAC 中的参数分为两类，全局参数和局部参数。SAC 命令的具体执行效果由全局参数
和局部参数决定。根据修改参数的类型，SAC命令可以分为两类：

- 参数设定类：修改 SAC 的全局参数值
- 操作执行类：修改局部参数值，并对数据进行某些操作

在启动 SAC 时，所有的参数都会被初始化为指定的“系统默认参数值”。
使用参数设定类命令的时候，其修改了 SAC 的全局参数，会影响接下来与之相关的
所有其它命令的执行效果。使用操作执行类命令的时候，在命令中设定参数，
相当于修改局部变量的值，不仅会影响当前命令的执行，也会影响之后所有\ **同名**\
命令的执行。

当你在某个命令中为某个选项指定了一个参数值的时候，该参数值会
成为该命令的该选项的“参数当前值”，该“参数当前值”即成为接下来所有
该命令的该选项的“当前默认值”。

鉴于 SAC 的这样一个特性，在一次会话中，多次执行同一个命令时，一定需要
注意选项的当前值是多少，因为这可能会影响到后面的一系列结果，这个必须
理解和牢记！

当你在一次会话中执行了很多个命令的时候，SAC 参数可能已经被弄得一片混乱，
你可以使用 :doc:`/commands/inicm` 命令在不退出 SAC 的情况下重新初始化。

下面用例子解释一下：

.. code-block:: console

    SAC> funcgen
    SAC> plot
    SAC> funcgen step delta 0.1 npts 1000
    SAC> plot
    SAC> funcgen boxcar
    SAC> plot

#. ``funcgen`` 的默认值为 ``funcgen impulse npts 100 delta 1.0 begin 0.``
#. 第一个 ``funcgen`` 命令没有使用任何选项和参数，其直接使用系统默认值，
   生成一个脉冲数据，并保存到内存中。该数据的起始时间为 ``0``\ ，
   采样周期为 ``1.0``\ ，数据点数为 ``100``
#. ``plot`` 命令会打开一个绘图窗口，并将内存中的数据绘制在窗口中
#. 第二个 ``funcgen`` 命令生成了一个step函数\ [3]_，并设置其采样周期为
   ``0.1``\ ，数据点数为 ``1000``
#. ``0.1`` 和 ``1000`` 分别成为 ``delta`` 和 ``npts`` 的“参数当前值”
#. 第三个 ``funcgen`` 命令生成了 boxcar 函数，从绘图结果可以看出 ``delta``
   的值为 ``0.1``\ ，\ ``npts`` 的值为 ``1000``\ ，即继承了上一次命令的参数值

.. [1] 其实可以有很多选项，这里都省略了。
.. [2] 也称为采样时间，即两次数据采样的时间间隔，本文档将统一使用“采样周期”。
.. [3] 注意：内存中的脉冲函数已经没了。
