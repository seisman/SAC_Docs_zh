\section{SAC命令初探}
\subsection{SAC命令长什么样？}
一个完整的SAC命令一般由``命令+选项+参数''构成，其中命令必须有，选项和
参数可以成对出现，也可以只出现其中一个。命令、选项以及参数之间用空格
分开。如果要将多个命令写在一行，要用分号隔开每个命令。例如：
\begin{SACCode}
SAC> funcgen random delta 0.1 npts 1000
SAC> rmean; rtrend; taper                 // 一行内多个命令用分号隔开
SAC> write rand.SAC
\end{SACCode}
其中，!funcgen!、!write!、!rmean!、!rtrend! 和 !taper! 是命令；
!random! 是选项；!0.1! 是选项 !delta! 的参数，!1000! 是选项
!npts! 的参数；而 !rand.SAC! 则是一个无选项的参数
\footnote{其实可以有很多选项，这里都省略了。}。

\begin{note}
官方文档的原文是“command”、“keyword”和“option”，本文档v2.0中译为“命令”、
“关键字”和“参数”。个人感觉，无论是官方的用词还是v2.0版的译词都很容易让
使用C语言和Linux的人困惑，因而v3.0中一律将其改为命令（command）、
选项（option）和参数（argument）。

这里解释一下选项（option）和参数（argument）的区别。一个命令有哪些
选项是由命令规定的，其控制了命令的一些特性，因而选项的作用是告诉命令
“\textbf{要}改某个特性”。但是具体\textbf{怎么}改呢？这个就交给参数
来控制了。命令或选项只规定了参数的类型（整型、浮点型、字符串、枚举型
或者逻辑型），用户需要根据自己的需求给定参数值。
\end{note}

\subsection{大小写}
SAC的命令和选项都是不区分大小写的，这意味着你可以根据自己的喜好使用
!funcgen! 或者 !FUNCGEN!，SAC在解释命令前都会将其转换
为大写字母。

需要注意的是，由于Linux本身是区分大小写的，所以对于出现在参数中的文件名、
目录名或者由引号包围的字符串来说，大小写是完全不同的。比如 !rand.SAC!
和 !RAND.SAC! 是两个完全不同的参数。

\subsection{命令简写}
SAC的大多数命令及选项都有简写形式。比如上面的命令简写形式如下：
\begin{SACCode}
SAC> fg r d 0.1 n 1000
SAC> rmean; rtr; taper
SAC> w rand.SAC
\end{SACCode}

命令和选项究竟可以简写成怎样的形式，是由SAC自身规定的。简写的好处在于，
在不产生歧义的前提下尽量减少用户的击键数；坏处在于，若对命令不是足够熟悉，
简写后的命令变得很难读和难理解。比如你一看就知道 !delta! 代表的
是采样周期\footnote{也称为采样时间，即两次数据采样的时间间隔，本文档将
统一使用``采样周期''。}，而 !d! 却不那么直观，可能是 !delta!，
也可能是 !demon!。所以，在终端调用SAC时，可以多用简写以减少击键数，
但在脚本中调用SAC时应仅使用那些常用命令的简写，不要滥用，否则一段时间后
你会看不懂自己写的脚本的。

\subsection{查看命令语法}
SAC自带了英文的帮助文档，详细解释了每个命令的语法，可以通过
\nameref{cmd:help} 命令查看相应文档：
\begin{SACCode}
SAC> help funcgen write   // 命令的简写是h fg w
\end{SACCode}
也可以直接查看 !$SACHOME/aux/help! 下的文档，或者查看本文档的
命令部分。

\subsection{参数默认值}
为了让SAC易学易用，几乎所有命令参数都有一个``系统默认参数值''，这些
``系统默认参数值''都是经过精心挑选的，同时用户又可以随时修改参数值。
这样的设计使得SAC易用同时又不失灵活性。

下面以C语言为例做一些说明\footnote{有些地方不是很准确。}，希望能够帮助
理解SAC参数的一些特点。

在C语言中，函数有主函数和子函数之分，变量又有全局变量和局部变量之分。
所有的变量都可以被初始化为适当的值。

任意一个子函数，都可以使用全局变量的值，即函数的执行可以被全局变量所控制，
同时也可以修改全局变量的值。这使得代码的管理和调试变得困难。实际写程序时
一般会定义专门的子函数来修改全局变量。

任意一个子函数，又都有自己的局部变量。这些局部变量在每次子函数被调用时
都会被定义、初始化、使用和赋值，一旦子函数调用结束，变量即被撤销。如果
给这些变量加上 !static! 修饰符，则这些局部变量变身为静态局部变量。

静态局部变量，会在程序刚开始的时候就完成初始化，也是唯一的一次初始化。
静态局部变量仅在定义它的子函数里可见，子函数可以任意修改静态局部变量的值，
但是每次子函数调用结束时变量不会被撤销，因此再次调用一个子函数时，静态
局部变量的值可能已经被上一次的子函数调用所修改。

SAC中有与之相对应的一些概念。sac就是一个主函数，每一个命令都是一个子函数。
所以SAC命令可以分为2类：
\begin{description}
\item[操作执行类] 对数据进行某些操作（受全局变量控制，同时又有自己的静态局部变量）
\item[参数设定类] 改变SAC的全局参数值（即C语言中专门用于修改全局变量的子函数）
\end{description}

在启动SAC（主函数）的时候，所有的选项（C语言中的全局变量和静态局部变量）
都会被初始化为指定的``系统默认参数值''（全局变量和静态局部变量的唯一一次
初始化）。

使用参数设定类命令的时候，其修改了SAC的全局参数，会影响接下来与之相关的
所有其它命令的执行效果。使用操作执行类命令的时候，在命令中设定参数，
相当于修改静态局部变量的值，不仅会影响当前命令的执行，也会影响之后所有
同名命令的执行。

当你在某个命令中为某个选项指定了一个参数值的时候，该参数值会
成为该命令的该选项的``参数当前值''，该``参数当前值''即成为接下来所有
该命令的该选项的``当前默认值''。

鉴于SAC的这样一个特性，在一次会话中，多次执行同一个命令时，一定需要
注意选项的当前值是多少，因为这可能会影响到后面的一系列结果，这个必须
理解和牢记！

\begin{note}
当你在一次会话中执行了很多个命令的时候，SAC参数可能已经被弄得一片混乱，
你可以使用 \nameref{cmd:inicm} 命令在不退出SAC的情况下重新初始化。
\end{note}

下面用例子解释一下：
\begin{SACCode}
SAC> funcgen
SAC> plot
SAC> funcgen step delta 0.1 npts 1000
SAC> plot
SAC> funcgen boxcar
SAC> plot
\end{SACCode}

\begin{enumerate}
\item !funcgen! 的默认值为 !funcgen impulse npts 100 delta 1.0 begin 0.!
\item 第一个 !funcgen! 命令没有使用任何选项和参数，其直接使用系统默认值，
    生成一个脉冲数据，并保存到内存中。该数据的起始时间为 !0!，
    采样周期为 !1.0!，数据点数为 !100!
\item !plot! 命令会打开一个绘图窗口，并将内存中的数据绘制在窗口中
\item 第二个 !funcgen! 命令生成了一个step函数\footnote{注意：
    内存中的脉冲函数已经没了。}，并设置其采样周期为 !0.1!，数据
    点数为 !1000!
\item !0.1! 和 !1000! 分别成为 !delta! 和
    !npts! 的``参数当前值''
\item 第三个 !funcgen! 命令生成了boxcar函数，从绘图结果可以看出
    !delta! 的值为 !0.1!，!npts! 的值为 !1000!，
    即继承了上一次命令的参数值
\end{enumerate}
