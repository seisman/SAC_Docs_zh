\SACCMD{readcss}
\label{cmd:readcss}

\SACTitle{概要}
从磁盘读取CSS文件到内存

注意：READCSS命令读取CSS 3.0或2.0的文本文件。
3.0版本支持如下数据库表：

wfdisc、wftag、origin、arrival、assoc、sitechan、site、affiliation、origerr、origin、event、sensor、instrument、gregion、
stassoc和remark sacdata。

2.8版本只支持wfdisc、arrival和origin。
READCSS之前的版本要求origin文件只有一行与波形有关%此句存疑
现在的版本可以用来自一个wftag文件或者wfdisc文件中an evid column的信息来提取正确的源(position 284 - 291)。%此句存疑
如果没有可用的信息，READCSS会默认以前的方式用origin文件的第一行。
现在，用READCSS读取数据不再会有数据丢失。
尽管现有的SAC命令只能获取一部分CSS数据，从CSS文本文件读取的存放在内存中的每个数据都可以用命令WRITECSS写入磁盘。

READCSS现在（可以）读取一个非标准的数据库表，名为sacdata(由WRITECSS命令输出的)。%此句存疑
比如，你现在可以用WRITECSS把频率域数据写入磁盘，然后用READCSS读取

READCSS现在有一个二进制选项，以便读取WRITECSS生成的二进制的CSS文件。
在二进制模式中，css选项没有作用。
也就是说，指定文件的全部内容都会读取。

READCSS支持如下的二进制数据格式：在大端序机器(比如Sun)上的t8、t4、f8、f4、s4、s3、s2、i4、i2、g2、e1和ri (real-imag)。

在小端序机器(比如DEC和PC)上： f8、f4、t8、t4、i4、i2、s4、s2和g2。

\SACTitle{语法}
\begin{SACSTX}
READCSS [BINARY|ASCII] [MAXMEM v] [MORE] [TRUST ON|OFF] [VERBOSE ON|OFF] 

[SHIFT ON|OFF] [SCALE ON|OFF] [COMMIT|ROLLBACK|RECALLTRACE] [DIR name] 

wfdisclist [filelist] [css options] [filelist]
\end{SACSTX}

css选项至少是下列之一：

\begin{SACSTX}
STATION station
CHANNEL channel
BANDWIDTH band code
ORIENTATION orientation code
\end{SACSTX}

这些选项使命令从符合相关记录内容的wfdisc文件中进行选择。

\SACTitle{输入}
\begin{description}
\item [ASCII] (默认)读取普通的文本文件
\item [BINARY]读取二进制CSS文件。见WRITECSS了解更多信息
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item [DIR name] wfdisc文件所在的路径
    \footnote{关于dir选项，有一个很大的陷阱，详见``\nameref{sec:read-dir}''。}
\item [XDR] 读取XDR格式的文件。此格式用于实现不同构架的二进制数据的转换
\item [ALPHA] 输入文件是SAC的字符数字型文件，该选项与XDR选项不兼容
\item [SEGY] 读取IRIS/PASSCAL定义的SEGY格式文件。该格式允许一个文件包含一个波形
\item [SCALE] 只能和SEGY选项搭配使用，该选项默认是关闭的。当SCALE选项为OFF时，
    SAC直接从SEGY文件中读取数据值；当SCALE为ON时，SAC将每个数据值乘以以文件中给定的
    SCALE因子。若SCALE为OFF，则这个文件中的SCALE值将储存在SAC头段SCALE中；若SCALE为ON，
    SAC的SCALE头段将被设置为1.0。
\item [filelist] 文件列表。可以是简单的文件名，也可以包含相对或绝对路径，也可以使用
    通配符。
\end{description}

\SACTitle{缺省值}
\begin{SACDFT}
read dir current
\end{SACDFT}

\SACTitle{说明}
该命令将SAC文件从磁盘读入到内存中，默认状态下会读取每个磁盘文件中的全部数据点。

\nameref{cmd:cut}命令可以用于指定读取文件的一部分数据。
在2000年之后产生的SAC文件会被假定年份为四位数字。
年份为两个数字的文件被假定为20世纪，会被加上1900。

在使用read命令时，正常情况下内存中的老数据会被新读取的数据所替代。若使用more选项，则新数据
将被读入内存并放在老数据的后面。在如下三种情况下more选项可能会有用：
\begin{itemize}
\item 文件列表太长无法在一行中键入
\item 在长文件列表中某个文件名拼错而没有读入，可以使用more选项再次读入
\item 一个文件被读入，作了些处理，然后与原始数据比较
\end{itemize}

\SACTitle{示例}
read命令的简单示例位于~``\nameref{sec:read-and-write}''~一节。

如果你想要对一个数据进行高通滤波，并与原始数据进行对比：
\begin{SACCode}
SAC> r f01
SAC> hp c 1.3 n 6
SAC> r more f01
SAC> p1
\end{SACCode}

假设SAC的启动目录位于``/me/data''，你想要处理其子目录``event1''和``event2''下的文件。
\begin{SACCode}
SAC> read dir event1 f01 f02
\end{SACCode}
读取了目录``/me/data/event1''下的文件。

\begin{SACCode}
SAC> read f03 g03
\end{SACCode}
相同目录下的文件被读入。

\begin{SACCode}
SAC> read dir event2 *
\end{SACCode}
``/me/data/event2''下的全部文件被读入:

\begin{SACCode}
SAC> read dir current f03 g03
\end{SACCode}
目录``/me/data''下的文件被读入。

\SACTitle{头段变量}
e、depmin、depmax、depmen、b

\SACTitle{相关命令}
\nameref{cmd:cut}、\nameref{cmd:readerr}、\nameref{cmd:wild}
